---
layout: post
title:  "Just a test"
author: Franz
categories: [ tutorial ]
---
# Franzplot: a teaching software (re)written in Rust

My name is Francesco Cattoglio and I have been a research assistant at Politecnico di Milano for a few years. Since 2018 I have also taken up the role of teaching assistant for a University class titled "Curves and Surfaces for Design". The goals of this class are to explain some 3D math concepts as parametric curves and surfaces to Design students. As with everything related to mathematics, grasping some abstract concepts without practical examples can be tricky, and this is even more true for the students I have been teaching to: they all come from different backgrounds. Some of them have a STEM one, others have attended an art high school, so even concept like "sum of two vectors" can be tricky for some.
To help with the teaching we spend about 15-20 hours in informatic lab to let the students turn ideas into shapes and images. Three years ago I saw the students struggling with the tool we were using (we used the PovRay renderer) I proposed to create a new tool from scratch. And we did, in just a four months, working on it as a side project, I managed to scrap together the first version of the new teaching software. Since my nickname at the office was Franz, my supervisor kept referring to it as "Franzplot". In the end, that was the name that stuck, and she still apologizes to me every time I show the software to my students for the first time because of how ridiculous it sounds!
The first version was written in C++, and used OpenGL via the Magnum library, which is a really amazing piece of work considering the very small team that put it together. I would really like to thank Mosra for making the first version of the Franzplot possible. Imgui was used to provide the node editor interface, which is the most important part of the whole project.
To keep it short: the user created a graph of nodes that inputs some math equations to create a given set of geometrical objects (parametrical curves or surfaces) and apply some transformation matrices to them. Then, at scene creation time, the CPU computes those shapes and the user can inspect the scene to see what those formulas look like.
If the first version was C++, how comes that the second version was built in Rust? Thing is, me, my advisor and other professors saw the potential and decided to turn this side project into a "real" software. However, to take things to the next level many things needed addressing. First and foremost, the amount of technical debt was rather high. Second, OpenGL has already been deprecated by Apple, and we could not afford the risk of having a third of our students being unable to run the software in the future if Apple decided to remove support alltogether. Third, and most importantly we wanted to make the tool more powerful, flexible and available as a webapp as well.
To enhance the interactivity of the software we needed to be able to recompute *everything* at least 30 times per second, so the simple formula interpreter that we were using would not cut it anymore. After realizing that even a cheap laptop iGPU has a huge amount of flops, I decided to go for a compute-based solution, but how can one have compute shaders on a webpage? Enters WebGPU.
I first heard of webgpu around March 2020, if memory serves. It was clear that everything was still a work in progress, but I already knew the amazing work made by the gfx-rs team and I was confident that wgpu-rs would have been the right bet. More than a year later I firmly stand by that.
Up until that point I had very little Rust experience, but I was already in love with the language (after all, I had spent the last two and a half years screaming at the debugger while trying to fix my C++ and FORTRAN77 code!). During a meeting I explained my supervisors that it would not be an easy nor a quick job, but that I was sure that the rust+wgpu combo would have been the right choice going forward: a modern language and a modern gpu API would have solved all our issues.
After many months of learning, opening github issues, getting help and advice from Kvark, Cwfitzgerald and many others from the community, we finally went live with the new version. The core was rust, with bindings to imgui for the UI and using cxx as a bridge to use the imnodes node graph editor. Most of the puzzle pieces fell right into their place, only requiring a minimal nudge to work together properly. At its core, the software reads the user-created graph. For each node, one wgpu compute shader is created which contains the equations that the user wrote. In a sense, Franzplot is "just" a compiler: it turns mathematical formulas into GLSL. Everything else is just some glue code with a super-simple 3D scene visualization on top.
The new version was a success: even though some bugs neeeded ironing, the final product has been very solid so far. There are even a couple students that were to run the *old*, OpenGL version on their laptops, but were instead able to run the new one!

There are still many things to decide w.r.t. the future steps: even though the new code was written from scratch, I still feel like some tecnical debt crept in, and there are a few changes I would like to make to the internals. Adding more features could be fun, especially if we manage to advertise the software a bit and find other universities that sport similar classes that might need a similar easy-to-use tool for their students. When it comes to internals, another thing that I would *love* to do is to ditch GLSL completely and move to WGLS, since it has matured a lot and would allow me to get rid of the huge shaderc dependency. At last, even though I enjoyed working with imnodes, I would like to find a rust-only solution for the UI. Right now I am investigating egui as a possible replacement for imgui, but right now this is kind of low-priority. 
